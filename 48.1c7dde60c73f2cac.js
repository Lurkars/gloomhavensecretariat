"use strict";(self.webpackChunkgloomhavensecretariat=self.webpackChunkgloomhavensecretariat||[]).push([[48],{6048:(Q,O,m)=>{m.r(O),m.d(O,{render:()=>re});var X=m(9204),N=m(1319),h=(m(3926),m(5771)),K=m(6273),t=(m(6974),m(8389),m(5595),m(4110)),Z=m(8512),D=m(3130),z=m(9115),G=m(5644);function w(n){var r={options:{directed:n.isDirected(),multigraph:n.isMultigraph(),compound:n.isCompound()},nodes:I(n),edges:$(n)};return D.A(n.graph())||(r.value=z.A(n.graph())),r}function I(n){return G.A(n.nodes(),function(r){var e=n.node(r),o=n.parent(r),i={v:r};return D.A(e)||(i.value=e),D.A(o)||(i.parent=o),i})}function $(n){return G.A(n.edges(),function(r){var e=n.edge(r),o={v:r.v,w:r.w};return D.A(r.name)||(o.name=r.name),D.A(e)||(o.value=e),o})}m(8414);var k=m(1823),l=new Map,p=new Map,U=new Map,L=(0,t.K2)(()=>{p.clear(),U.clear(),l.clear()},"clear"),P=(0,t.K2)((n,r)=>{const e=p.get(r)||[];return t.Rm.trace("In isDescendant",r," ",n," = ",e.includes(n)),e.includes(n)},"isDescendant"),q=(0,t.K2)((n,r)=>{const e=p.get(r)||[];return t.Rm.info("Descendants of ",r," is ",e),t.Rm.info("Edge is ",n),n.v!==r&&n.w!==r&&(e?e.includes(n.v)||P(n.v,r)||P(n.w,r)||e.includes(n.w):(t.Rm.debug("Tilt, ",r,",not in descendants"),!1))},"edgeInCluster"),M=(0,t.K2)((n,r,e,o)=>{t.Rm.warn("Copying children of ",n,"root",o,"data",r.node(n),o);const i=r.children(n)||[];n!==o&&i.push(n),t.Rm.warn("Copying (nodes) clusterId",n,"nodes",i),i.forEach(c=>{if(r.children(c).length>0)M(c,r,e,o);else{const d=r.node(c);t.Rm.info("cp ",c," to ",o," with parent ",n),e.setNode(c,d),o!==r.parent(c)&&(t.Rm.warn("Setting parent",c,r.parent(c)),e.setParent(c,r.parent(c))),n!==o&&c!==n?(t.Rm.debug("Setting parent",c,n),e.setParent(c,n)):(t.Rm.info("In copy ",n,"root",o,"data",r.node(n),o),t.Rm.debug("Not Setting parent for node=",c,"cluster!==rootId",n!==o,"node!==clusterId",c!==n));const u=r.edges(c);t.Rm.debug("Copying Edges",u),u.forEach(a=>{t.Rm.info("Edge",a);const g=r.edge(a.v,a.w,a.name);t.Rm.info("Edge data",g,o);try{q(a,o)?(t.Rm.info("Copying as ",a.v,a.w,g,a.name),e.setEdge(a.v,a.w,g,a.name),t.Rm.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):t.Rm.info("Skipping copy of edge ",a.v,"--\x3e",a.w," rootId: ",o," clusterId:",n)}catch(E){t.Rm.error(E)}})}t.Rm.debug("Removing node",c),r.removeNode(c)})},"copy"),F=(0,t.K2)((n,r)=>{const e=r.children(n);let o=[...e];for(const i of e)U.set(i,n),o=[...o,...F(i,r)];return o},"extractDescendants"),ee=(0,t.K2)((n,r,e)=>{const o=n.edges().filter(a=>a.v===r||a.w===r),i=n.edges().filter(a=>a.v===e||a.w===e),c=o.map(a=>({v:a.v===r?e:a.v,w:a.w===r?r:a.w})),d=i.map(a=>({v:a.v,w:a.w}));return c.filter(a=>d.some(g=>a.v===g.v&&a.w===g.w))},"findCommonEdges"),b=(0,t.K2)((n,r,e)=>{const o=r.children(n);if(t.Rm.trace("Searching children of id ",n,o),o.length<1)return n;let i;for(const c of o){const d=b(c,r,e),u=ee(r,e,d);if(d){if(!(u.length>0))return d;i=d}}return i},"findNonClusterChild"),Y=(0,t.K2)(n=>l.has(n)&&l.get(n).externalConnections&&l.has(n)?l.get(n).id:n,"getAnchorId"),ne=(0,t.K2)((n,r)=>{if(!n||r>10)t.Rm.debug("Opting out, no graph ");else{t.Rm.debug("Opting in, graph "),n.nodes().forEach(function(e){n.children(e).length>0&&(t.Rm.warn("Cluster identified",e," Replacement id in edges: ",b(e,n,e)),p.set(e,F(e,n)),l.set(e,{id:b(e,n,e),clusterData:n.node(e)}))}),n.nodes().forEach(function(e){const o=n.children(e),i=n.edges();o.length>0?(t.Rm.debug("Cluster identified",e,p),i.forEach(c=>{P(c.v,e)^P(c.w,e)&&(t.Rm.warn("Edge: ",c," leaves cluster ",e),t.Rm.warn("Descendants of XXX ",e,": ",p.get(e)),l.get(e).externalConnections=!0)})):t.Rm.debug("Not a cluster ",e,p)});for(let e of l.keys()){const o=l.get(e).id,i=n.parent(o);i!==e&&l.has(i)&&!l.get(i).externalConnections&&(l.get(e).id=i)}n.edges().forEach(function(e){const o=n.edge(e);t.Rm.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),t.Rm.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let i=e.v,c=e.w;if(t.Rm.warn("Fix XXX",l,"ids:",e.v,e.w,"Translating: ",l.get(e.v)," --- ",l.get(e.w)),l.get(e.v)||l.get(e.w)){if(t.Rm.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),i=Y(e.v),c=Y(e.w),n.removeEdge(e.v,e.w,e.name),i!==e.v){const d=n.parent(i);l.get(d).externalConnections=!0,o.fromCluster=e.v}if(c!==e.w){const d=n.parent(c);l.get(d).externalConnections=!0,o.toCluster=e.w}t.Rm.warn("Fix Replacing with XXX",i,c,e.name),n.setEdge(i,c,o,e.name)}}),t.Rm.warn("Adjusted Graph",w(n)),W(n,0),t.Rm.trace(l)}},"adjustClustersAndEdges"),W=(0,t.K2)((n,r)=>{if(t.Rm.warn("extractor - ",r,w(n),n.children("D")),r>10)return void t.Rm.error("Bailing out");let e=n.nodes(),o=!1;for(const i of e){const c=n.children(i);o=o||c.length>0}if(o){t.Rm.debug("Nodes = ",e,r);for(const i of e)if(t.Rm.debug("Extracting node",i,l,l.has(i)&&!l.get(i).externalConnections,!n.parent(i),n.node(i),n.children("D")," Depth ",r),l.has(i))if(!l.get(i).externalConnections&&n.children(i)&&n.children(i).length>0){t.Rm.warn("Cluster without external connections, without a parent and with children",i,r);let d="TB"===n.graph().rankdir?"LR":"TB";l.get(i)?.clusterData?.dir&&(d=l.get(i).clusterData.dir,t.Rm.warn("Fixing dir",l.get(i).clusterData.dir,d));const u=new k.T({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});t.Rm.warn("Old graph before copy",w(n)),M(i,n,u,i),n.setNode(i,{clusterNode:!0,id:i,clusterData:l.get(i).clusterData,label:l.get(i).label,graph:u}),t.Rm.warn("New graph after copy node: (",i,")",w(u)),t.Rm.debug("Old graph after copy",w(n))}else t.Rm.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l.get(i).externalConnections," no parent: ",!n.parent(i)," children ",n.children(i)&&n.children(i).length>0,n.children("D"),r),t.Rm.debug(l);else t.Rm.debug("Not a cluster",i,r);e=n.nodes(),t.Rm.warn("New list of nodes",e);for(const i of e){const c=n.node(i);t.Rm.warn(" Now next level",i,c),c?.clusterNode&&W(c.graph,r+1)}}else t.Rm.debug("Done, no node has children",n.nodes())},"extractor"),H=(0,t.K2)((n,r)=>{if(0===r.length)return[];let e=Object.assign([],r);return r.forEach(o=>{const i=n.children(o),c=H(n,i);e=[...e,...c]}),e},"sorter"),te=(0,t.K2)(n=>H(n,n.children()),"sortNodesByHierarchy"),V=(0,t.K2)(function(){var n=(0,X.A)(function*(r,e,o,i,c,d){t.Rm.warn("Graph in recursive render:XAX",w(e),c);const u=e.graph().rankdir;t.Rm.trace("Dir in recursive render - dir:",u);const a=r.insert("g").attr("class","root");e.nodes()?t.Rm.info("Recursive render XXX",e.nodes()):t.Rm.info("No nodes found for",e),e.edges().length>0&&t.Rm.info("Recursive edges",e.edge(e.edges()[0]));const g=a.insert("g").attr("class","clusters"),E=a.insert("g").attr("class","edgePaths"),C=a.insert("g").attr("class","edgeLabels"),y=a.insert("g").attr("class","nodes");yield Promise.all(e.nodes().map(function(){var v=(0,X.A)(function*(f){const s=e.node(f);if(void 0!==c){const R=JSON.parse(JSON.stringify(c.clusterData));t.Rm.trace("Setting data for parent cluster XXX\n Node.id = ",f,"\n data=",R.height,"\nParent cluster",c.height),e.setNode(c.id,R),e.parent(f)||(t.Rm.trace("Setting parent",f,c.id),e.setParent(f,c.id,R))}if(t.Rm.info("(Insert) Node XXX"+f+": "+JSON.stringify(e.node(f))),s?.clusterNode){t.Rm.info("Cluster identified XBX",f,s.width,e.node(f));const{ranksep:R,nodesep:A}=e.graph();s.graph.setGraph({...s.graph.graph(),ranksep:R+25,nodesep:A});const S=yield V(y,s.graph,o,i,e.node(f),d),j=S.elem;(0,h.lC)(s,j),s.diff=S.diff||0,t.Rm.info("New compound node after recursive render XAX",f,"width",s.width,"height",s.height),(0,h.U7)(j,s)}else e.children(f).length>0?(t.Rm.trace("Cluster - the non recursive path XBX",f,s.id,s,s.width,"Graph:",e),t.Rm.trace(b(s.id,e)),l.set(s.id,{id:b(s.id,e),node:s})):(t.Rm.trace("Node - the non recursive path XAX",f,y,e.node(f),u),yield(0,h.on)(y,e.node(f),{config:d,dir:u}))});return function(f){return v.apply(this,arguments)}}())),yield(0,t.K2)((0,X.A)(function*(){const v=e.edges().map(function(){var f=(0,X.A)(function*(s){const R=e.edge(s.v,s.w,s.name);t.Rm.info("Edge "+s.v+" -> "+s.w+": "+JSON.stringify(s)),t.Rm.info("Edge "+s.v+" -> "+s.w+": ",s," ",JSON.stringify(e.edge(s))),t.Rm.info("Fix",l,"ids:",s.v,s.w,"Translating: ",l.get(s.v),l.get(s.w)),yield(0,N.jP)(C,R)});return function(s){return f.apply(this,arguments)}}());yield Promise.all(v)}),"processEdges")(),t.Rm.info("Graph before layout:",JSON.stringify(w(e))),t.Rm.info("############################################# XXX"),t.Rm.info("###                Layout                 ### XXX"),t.Rm.info("############################################# XXX"),(0,Z.Zp)(e),t.Rm.info("Graph after layout:",JSON.stringify(w(e)));let B=0,{subGraphTitleTotalMargin:T}=(0,K.O)(d);return yield Promise.all(te(e).map(function(){var v=(0,X.A)(function*(f){const s=e.node(f);if(t.Rm.info("Position XBX => "+f+": ("+s.x,","+s.y,") width: ",s.width," height: ",s.height),s?.clusterNode)s.y+=T,t.Rm.info("A tainted cluster node XBX1",f,s.id,s.width,s.height,s.x,s.y,e.parent(f)),l.get(s.id).node=s,(0,h.U_)(s);else if(e.children(f).length>0){t.Rm.info("A pure cluster node XBX1",f,s.id,s.x,s.y,s.width,s.height,e.parent(f)),s.height+=T,e.node(s.parentId);const R=s?.padding/2||0,A=s?.labelBBox?.height||0;t.Rm.debug("OffsetY",A-R||0,"labelHeight",A,"halfPadding",R),yield(0,h.U)(g,s),l.get(s.id).node=s}else{const R=e.node(s.parentId);s.y+=T/2,t.Rm.info("A regular node XBX1 - using the padding",s.id,"parent",s.parentId,s.width,s.height,s.x,s.y,"offsetY",s.offsetY,"parent",R,R?.offsetY,s),(0,h.U_)(s)}});return function(f){return v.apply(this,arguments)}}())),e.edges().forEach(function(v){const f=e.edge(v);t.Rm.info("Edge "+v.v+" -> "+v.w+": "+JSON.stringify(f),f),f.points.forEach(S=>S.y+=T/2);const s=e.node(v.v);var R=e.node(v.w);const A=(0,N.Jo)(E,f,l,o,s,R,i);(0,N.T_)(f,A)}),e.nodes().forEach(function(v){const f=e.node(v);t.Rm.info(v,f.type,f.diff),f.isGroup&&(B=f.diff)}),t.Rm.warn("Returning from recursive render XAX",a,B),{elem:a,diff:B}});return function(r,e,o,i,c,d){return n.apply(this,arguments)}}(),"recursiveRender"),re=(0,t.K2)(function(){var n=(0,X.A)(function*(r,e){const o=new k.T({multigraph:!0,compound:!0}).setGraph({rankdir:r.direction,nodesep:r.config?.nodeSpacing||r.config?.flowchart?.nodeSpacing||r.nodeSpacing,ranksep:r.config?.rankSpacing||r.config?.flowchart?.rankSpacing||r.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),i=e.select("g");(0,N.g0)(i,r.markers,r.type,r.diagramId),(0,h.gh)(),(0,N.IU)(),(0,h.IU)(),L(),r.nodes.forEach(d=>{o.setNode(d.id,{...d}),d.parentId&&o.setParent(d.id,d.parentId)}),t.Rm.debug("Edges:",r.edges),r.edges.forEach(d=>{if(d.start===d.end){const u=d.start,a=u+"---"+u+"---1",g=u+"---"+u+"---2",E=o.node(u);o.setNode(a,{domId:a,id:a,parentId:E.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),o.setParent(a,E.parentId),o.setNode(g,{domId:g,id:g,parentId:E.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),o.setParent(g,E.parentId);const C=structuredClone(d),y=structuredClone(d),x=structuredClone(d);C.label="",C.arrowTypeEnd="none",C.id=u+"-cyclic-special-1",y.arrowTypeStart="none",y.arrowTypeEnd="none",y.id=u+"-cyclic-special-mid",x.label="",E.isGroup&&(C.fromCluster=u,x.toCluster=u),x.id=u+"-cyclic-special-2",x.arrowTypeStart="none",o.setEdge(u,a,C,u+"-cyclic-special-0"),o.setEdge(a,g,y,u+"-cyclic-special-1"),o.setEdge(g,u,x,u+"-cyc<lic-special-2")}else o.setEdge(d.start,d.end,{...d},d.id)}),t.Rm.warn("Graph at first:",JSON.stringify(w(o))),ne(o),t.Rm.warn("Graph after XAX:",JSON.stringify(w(o)));const c=(0,t.D7)();yield V(i,o,r.type,r.diagramId,void 0,c)});return function(r,e){return n.apply(this,arguments)}}(),"render")},9115:(Q,O,m)=>{m.d(O,{A:()=>h});var X=m(5973);const h=function J(K){return(0,X.A)(K,4)}}}]);
//# sourceMappingURL=48.1c7dde60c73f2cac.js.map